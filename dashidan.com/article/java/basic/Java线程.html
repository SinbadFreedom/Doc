<!doctype html>
<html class="no-js" lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <title>Java线程</title>
    <meta name="description" content="Java线程">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta http-equiv="Expires" content="0">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Cache-control" content="no-cache">
    <meta http-equiv="Cache" content="no-cache">

    <link rel="stylesheet" href="http://dashidan.com/css/bootstrap.css">
    <link rel="stylesheet" href="http://dashidan.com/css/dashidan.css">
</head>
<body>
<!--[if lte IE 9]>
<p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade
    your browser</a> to improve your experience and security.</p>
<![endif]-->

<nav class="navbar navbar-default">
    <div class="container">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse"
                    data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="#">
                <img src="http://dashidan.com/img/dsd24.png">
            </a>
            <a class="navbar-brand" href="http://dashidan.com/index.html">大屎蛋教程网</a>
        </div>
        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav navbar-right">
                <li><a href="http://dashidan.com/about.html">关于</a></li>
            </ul>
        </div>
    </div>
</nav>

<div class="container">
    <!-- 顶部面包屑导航-->
    <ol class="breadcrumb">
        <li><a href="http://dashidan.com/index.html"><b>首页</b></a></li>
        <li><a href="http://dashidan.com/article/java/index.html"><b>Java教程</b></a></li>
        <li class="active"><a
            href="http://dashidan.com/article/java/basic/index.html"><b>教程列表</b></a></li>
    </ol>
    <hr>
    <!-- 顶部标签页-->
    <ul class="nav nav-tabs" role="tablist">
        <li class="active"><a href="http://dashidan.com/article/java/basic/index.html">教程列表</a></li>
        <li><a href="http://dashidan.com/article/java/addenda/index.html">附录</a></li>
    </ul>
    <!--文档区-->
    <div>
        👯转载请保留原文链接👉:<a href="http://dashidan.com/article/java/basic/Java线程.html">http://dashidan.com/article/java/basic/Java线程.html</a>
    </div>

    <div>
        <!-- 替换这个区域-->
        <div>
            <div class="dsd_title"><h1>18. Java线程</h1></div>
            <div class="dsd_catalog"><a href="#①">① 线程和进程的概念</a>
                <hr>
                <a href="#②">② 线程的实现</a>
                <hr>
                <a href="#③">③ Java线程调度</a>
                <hr>
                <a href="#④">④ Java中线程的实现</a>
                <hr>
                <a href="#⑤">⑤ 启动线程</a>
                <hr>
                <a href="#⑥">⑥ Java线程的状态</a>
                <hr>
                <a href="#⑦">⑦ 线程死锁</a>
                <hr>
                <a href="#⑧">⑧ synchronized用在对象, 方法, 代码块的区别</a>
                <hr>
                <a href="#⑨">⑨ Lock对象</a>
                <hr>
                <a href="#⑩">⑩ 线程常见问题 </a>
                <hr>
                <a href="#⑪">⑪ 相关文章</a></div>
        </div>
        <div class="jumbotron">
            <p>部分内容源自:《深入理解JVM虚拟机》.
            </p>
        </div>
        <div class="dsd_title"><a href="#top" id="①">① 线程和进程的概念🔝</a></div>
        <p>进程是指一个内存中运行有自己独立的一块内存空间的应用程序.一个进程中至少一个线程.</p>
        <p>线程是指进程中的一个执行流程.每个线程有独立的运行栈. 线程从属于进程. 一个进程中可以运行多个线程.进程中的多个线程共享进程的内存.</p>
        <p>线程和进程一样分为五个阶段:创建、就绪、运行、阻塞、终止.</p>
        <p>多进程是指操作系统能同时运行多个任务(程序).</p>
        <p>多线程是指在同一程序中,有多个顺序流在执行.</p>
        <p><img class="center-block img-responsive" src="http://dashidan.com/img/java/basic/18-1.jpg" alt="线程"/></p>
        <div class="dsd_title"><a href="#top" id="②">② 线程的实现🔝</a></div>
        <p>线程是比进程更轻量级的调度执行单位,线程的引入,可以把一个进程的资源分配和执行调度分开,各个线程既可以共享进程资源(内存地址、文件I/O等),又可以独立调度(线程是CPU调度的基本单位).</p>
        <p>主流的操作系统都提供了线程实现,Java语言则提供了在不同硬件和操作系统平台下对线程操作的统一处理.</p>
        <p>Thread类中所有关键方法都是声明为Native的,在Java API中,本地方法往往意味着这个方法没有使用或无法使用平台无关的手段来实现(当然也有可能是为了执行效率而使用Native方法)</p>
        <div class="dsd_title"><a href="#top" id="③">③ Java线程调度🔝</a></div>
        <p>Java的线程调度方式是抢占式调度,虽然Java线程的调度是系统自动完成的,但是我们还是可以“建议”系统给某些线程多分配一点执行时间,另外的一些线程则可以少分配一点——这项操作可以通过设置优先级来完成.</p>
        <p>
            不过,线程的优先级并不是太靠谱,因为Java线程是通过映射到原生线程上来实现的,所以线程调度最终还是取决于操作系统,虽然现在很多操作系统都提供了优先级的概念,但是并不见得与Java线程的优先级一一对应.比如:Windows中就只有7种线程优先级,而Java语言一共设置了10个级别的线程优先级.</p>
        <div class="dsd_title"><a href="#top" id="④">④ Java中线程的实现🔝</a></div>
        <p>在Java中想实现多线程有两种手段,一种是集成Thread类,另一种就是实现Runnable接口.</p>
        <h3>1.继承自Thread类</h3>
        <pre class="prettyprint"><code class="java language-java">package com.dashidan.lesson18;

/**
 * 大屎蛋教程网-dashidan.com
 * &lt;p&gt;
 * Java教程基础篇:  18.Java线程
 * 继承自Thread类
 */
public class MyThread1 extends Thread {

    @Override
    public void run() {
        System.out.println("MyThread1 run.");
    }
}
</code></pre>
        <h3>2.实现Runnable接口</h3>
        <p>首先定义一个线程类继承自Runnable接口,如: </p>
        <pre class="prettyprint"><code class="java language-java">package com.dashidan.lesson18;

/**
 * 大屎蛋教程网-dashidan.com
 * &lt;p&gt;
 * Java教程基础篇:  18.Java线程
 * 实现Runnable接口
 */
public class MyThread2 implements Runnable {
    @Override
    public void run() {
        System.out.println("MyThread2 run.");
    }
}
</code></pre>
        <p>入口类,实例化线程类的对象,发动启动线程的命令</p>
        <pre class="prettyprint"><code class="java language-java">package com.dashidan.lesson18;

/**
 * 大屎蛋教程网-dashidan.com
 * &lt;p&gt;
 * Java教程基础篇:  18.Java线程
 */
public class Demo1 {
    public static void main(String[] args) {
        MyThread1 t1 = new MyThread1();
        /** t1 线程启动*/
        t1.start();
        MyThread2 myThread2 = new MyThread2();
        Thread t2 = new Thread(myThread2);
        /** t2 线程启动*/
        t2.start();
    }
}
</code></pre>
        <p>输出:</p>
        <pre><code>MyThread2 run.
MyThread1 run.
</code></pre>
        <div class="bs-callout bs-callout-warning">
            <h4>输出的顺序可能不一致</h4>
            <p>多运行几次, 输出的顺序可能不一致, 这个是由于线程的执行顺序无法保证导致.</p>
        </div>
        <div class="bs-callout bs-callout-success">
            <h4>继承Thread和实现Runnable接口如何选择</h4>
            <p>由于Java是单根继承体系, 当一个类需要继承与其他类, 还需要具有线程的能力, 这时只能采用实现Runable接口的方式.</p>
        </div>
        <div class="dsd_title"><a href="#top" id="⑤">⑤ 启动线程🔝</a></div>
        <p>在线程的Thread对象上调用start()方法,而不是run()或者别的方法.在调用start()方法之前,线程处于新状态中, 新状态指有一个Thread对象, 但还没有一个真正的线程.
            在调用start()方法之后,发生了一系列复杂的事情</p>
        <ol>
            <li>启动新的执行线程(具有新的调用栈).</li>
            <li>该线程从新状态转移到可运行状态.</li>
            <li>当该线程获得机会执行时,其目标run()方法将运行.</li>
        </ol>
        <div class="bs-callout bs-callout-danger">
            <h4>run()方法</h4>
            <p>对Java来说,run()方法是线程启动的入口方法, 同时也是一个普通的方法. 因此,在Runnable上或者Thread上调用run方法是合法的.但并不启动新的线程.所以不建议直接调用run()方法.</p>
        </div>
        <div class="dsd_title"><a href="#top" id="⑥">⑥ Java线程的状态🔝</a></div>
        <p>Java线程具有五中基本状态</p>
        <ol>
            <li>新建状态(New)</li>
        </ol>
        <p>在生成线程对象,并没有调用该对象的start方法.如:</p>
        <pre class="prettyprint"><code class="java language-java">Thread t = new MyThread1();
</code></pre>
        <ol>
            <li>就绪状态(Runnable)</li>
        </ol>
        <p>当调用了线程对象的start方法之后,该线程就进入了就绪状态,但是此时线程调度程序还没有把该线程设置为当前线程,此时处于就绪状态.随时等待CPU调度执行,并不是说执行了t.start()此线程立即就会执行.
            在线程运行之后,从等待或者睡眠中回来之后,也会处于就绪状态.</p>
        <ol>
            <li>运行状态(Running)</li>
        </ol>
        <p>线程调度程序将处于就绪状态的线程设置为当前线程,此时线程就进入了运行状态,开始运行run函数当中的代码.就绪状态是进入到运行状态的唯一入口,也就是说,线程要想进入运行状态执行,首先必须处于就绪状态中.</p>
        <ol>
            <li>阻塞状态(Blocked)</li>
        </ol>
        <p>线程正在运行的时候,暂时放弃对CPU的使用权,停止执行,此时进入阻塞状态.通常是为了等待某个时间的发生(比如说某项资源就绪)之后再继续运行.sleep,suspend,wait等方法都可以导致线程阻塞.</p>
        <p>处于运行状态中的线程直到其进入到就绪状态,才有机会再次被CPU调用以进入到运行状态.根据阻塞产生的原因不同,阻塞状态又可以分为三种:</p>
        <ul>
            <li>等待阻塞</li>
        </ul>
        <p>运行状态中的线程执行wait()方法,使本线程进入到等待阻塞状态.
            wait()、notify()、notifyAll()是三个定义在Object类里的方法，可以用来控制线程的状态.
            任何一个时刻，对象的控制权（monitor）只能被一个线程拥有.
            无论是执行对象的wait、notify还是notifyAll方法，必须保证当前运行的线程取得了该对象的控制权（monitor）
            如果在没有控制权的线程里执行对象的以上三种方法，就会报java.lang.IllegalMonitorStateException异常.</p>
        <p>执行时wait(), sleep()时会抛出InterruptedException, 需要放在try-catch语句中执行.</p>
        <p>报错示例:</p>
        <pre class="prettyprint"><code class="java language-java">package com.dashidan.lesson18;

/**
 * 大屎蛋教程网-dashidan.com
 * &lt;p&gt;
 * Java教程基础篇:  18.Java线程
 * 线程阻塞状态-wait()
 */
public class WaitThread extends Thread {
    @Override
    public void run() {
        System.out.println("WaitThread run.");
        try {
            System.out.println("WaitThread before wait.");
            this.wait();
            System.out.println("WaitThread after wait.");
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
        <p>入口类:</p>
        <pre class="prettyprint"><code class="java language-java">package com.dashidan.lesson18;

/**
 * 大屎蛋教程网-dashidan.com
 * &lt;p&gt;
 * Java教程基础篇:  18.Java线程
 * 线程阻塞状态 wait()
 */
public class Demo2 {
    public static void main(String[] args) {
        WaitThread waitThread = new WaitThread();
        waitThread.start();
    }
}
</code></pre>
        <p>输出:</p>
        <pre><code>WaitThread run.
WaitThread before wait.
Exception in thread "Thread-0" java.lang.IllegalMonitorStateException
    at java.lang.Object.wait(Native Method)
    at java.lang.Object.wait(Object.java:502)
    at com.dashidan.lesson18.WaitThread.run(WaitThread.java:15)
</code></pre>
        <p>线程取得控制权的方法有三种:</p>
        <ul>
            <li>执行对象的某个同步实例方法.</li>
            <li>执行对象对应类的同步静态方法.</li>
            <li>执行对该对象加同步锁的同步块.</li>
        </ul>
        <p>如果对象调用了wait方法就会使持有该对象的线程把该对象的控制权交出去，然后处于等待状态.
            如果对象调用了notify方法就会通知某个正在等待这个对象的控制权的线程可以继续运行, 由Java虚拟机来决定哪个线程继续运行.
            如果对象调用了notifyAll方法就会通知所有等待这个对象控制权的线程继续运行
            可以通过synchronize关键字来获取同步锁, 然后再调用wait(), notify(), notifyAll().</p>
        <pre class="prettyprint"><code class="java language-java">package com.dashidan.lesson18;

/**
 * 大屎蛋教程网-dashidan.com
 * &lt;p&gt;
 * Java教程基础篇:  18.Java线程
 * 线程阻塞状态 wait() , 获得同步锁
 */
public class Demo3 {

    public static Object object = new Object();

    public static void main(String[] args) {
        WaitThread waitThread = new WaitThread(object);
        waitThread.start();

        try {
            /** 主线程休眠3秒*/
            System.out.println("主线程休眠3秒");
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        /** 3秒后执行 notifyAll */
        synchronized (object) {
            object.notifyAll();
        }
    }
}

class WaitThread extends Thread {
    Object object;

    public WaitThread(Object object) {
        this.object = object;
    }

    @Override
    public void run() {
        System.out.println("WaitThread run.");
        synchronized (object) {
            try {
                System.out.println("WaitThread before lock " + this.getName());
                object.wait();
                System.out.println("WaitThread after lock " + this.getName());
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
</code></pre>
        <p>输出:</p>
        <pre><code>主线程休眠3秒
WaitThread run.
WaitThread before lock Thread-0
WaitThread after lock Thread-0
</code></pre>
        <ul>
            <li>同步阻塞</li>
        </ul>
        <p>线程在获取synchronized同步锁失败(因为锁被其它线程所占用),它会进入同步阻塞状态. 当锁被释放后, 其他获得该锁的线程继续执行.</p>
        <pre class="prettyprint"><code class="java language-java">package com.dashidan.lesson18;

/**
 * 大屎蛋教程网-dashidan.com
 * &lt;p&gt;
 * Java教程基础篇:  18.Java线程
 * 线程阻塞状态 同步阻塞
 */
public class Demo5 {
    public static Object lock = new Object();

    public static void main(String[] args) {
        SyncThread syncThread = new SyncThread("t1", lock);
        syncThread.start();

        SyncThread syncThread1 = new SyncThread("t2",lock);
        syncThread1.start();
    }
}

class SyncThread extends Thread {
    public Object lock;

    public SyncThread(String name, Object lock) {
        super(name);
        this.lock = lock;
    }

    @Override
    public void run() {
        try {
            synchronized (lock) {
                /** 一个线程执行这个语句块的时候，另一个线程等待. */
                System.out.println(this.getName() + " before sleep.");
                Thread.sleep(3000);
                System.out.println(this.getName() + " after sleep.");
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
        <p>输出:</p>
        <pre><code>t2 before sleep.
t2 after sleep.
t1 before sleep.
t1 after sleep.
</code></pre>
        <div class="bs-callout bs-callout-success">
            <h4>多运行几次, 输出结果可能不一致, 但每次都是执行完一个线程, 再执行另一个.</h4>
        </div>
        <div class="bs-callout bs-callout-success">
            <h4>sleep()方法会释放cpu, 进入等待执行的状态, 但不会释放所持对象的锁.</h4>
        </div>
        <ul>
            <li>其他阻塞</li>
        </ul>
        <p>通过调用线程的sleep()或join()或发出了I/O请求时,线程会进入到阻塞状态.当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时,线程重新转入就绪状态.</p>
        <p>sleep示例:</p>
        <pre class="prettyprint"><code class="java language-java">package com.dashidan.lesson18;

/**
 * 大屎蛋教程网-dashidan.com
 * &lt;p&gt;
 * Java教程基础篇:  18.Java线程
 * 线程阻塞状态 sleep()
 */
public class Demo4 {
    public static void main(String[] args) {
        SleepThread thread = new SleepThread();
        thread.start();
    }
}

class SleepThread extends Thread {
    @Override
    public void run() {
        try {
            System.out.println("before sleep.");
            /** 休眠3秒*/
            Thread.sleep(3000);
            /** 3秒后输出*/
            System.out.println("after sleep.");
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
        <p>输出:</p>
        <pre><code>before sleep.
after sleep.
</code></pre>
        <ol>
            <li>死亡状态(Dead)</li>
        </ol>
        <p>如果一个线程的run方法执行结束或者调用stop方法后,该线程就会死亡结束生命周期.对于已经死亡的线程,无法再使用start方法令其进入就绪.</p>
        <div class="dsd_title"><a href="#top" id="⑦">⑦ 线程死锁🔝</a></div>
        <p>线程死锁是指2个线程都在同步阻塞状态, 等待对象的锁, 在对方的线程中无法释放. 这样会导致这两个线程卡死, 无法继续执行. 开发时应极力避免.</p>
        <pre class="prettyprint"><code class="java language-java">package com.dashidan.lesson18;


/**
 * 大屎蛋教程网-dashidan.com
 * &lt;p&gt;
 * Java教程基础篇:  18.Java线程
 * 线程死锁
 */
public class Demo6 {

    public static LockObject lockA = new LockObject("LOCK-A");
    public static LockObject lockB = new LockObject("LOCK-B");

    public static void main(String[] args) {
        /** 注意这两个线程传入的参数，顺序不一样, lockA, lockB*/
        LockThread thread1 = new LockThread("t1", lockA, lockB);
        thread1.start();
        /** 注意这两个线程传入的参数，顺序不一样, lockB, lockA*/
        LockThread thread2 = new LockThread("t2", lockB, lockA);
        thread2.start();
    }
}

class LockThread extends Thread {

    LockObject lock0;
    LockObject lock1;

    public LockThread(String name, LockObject lock0, LockObject lock1) {
        super(name);
        this.lock0 = lock0;
        this.lock1 = lock1;
    }

    @Override
    public void run() {
        try {
            synchronized (lock0) {
                System.out.println(getName() + "持有对象锁 " + lock0.getName());
                Thread.sleep(3000);
                System.out.println(getName() + "等待对象锁 " + lock1.getName() + " ... ");
                synchronized (lock1) {
                    System.out.println(getName() + "持有对象锁 " + lock1.getName());
                    Thread.sleep(3000);
                }
                /** Attention！这一行并没有输出*/
                System.out.println(getName() + "执行完毕");
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

/**
 * 一个简单的锁对象
 */
class LockObject {
    /**
     * 对象名字
     */
    private String name;

    public LockObject(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }
}
</code></pre>
        <p>输出:</p>
        <pre><code>t1持有对象锁 LOCK-A
t2持有对象锁 LOCK-B
t2等待对象锁 LOCK-A ...
t1等待对象锁 LOCK-B ...
</code></pre>
        <div class="bs-callout bs-callout-warning">
            <h4>执行完毕这一句并没有输出.</h4>
            <p>是因为两个线程进入了线程死锁状态, 互相等待对方释放锁. 编码过程中要极力避免嵌套调用锁的情况出现..</p>
        </div>
        <p>线程死锁如何检测?
            限于篇幅问题, 新建一篇来说明.<a href="http://dashidan.com">Java线程死锁检测</a>.</p>
        <div class="dsd_title"><a href="#top" id="⑧">⑧ synchronized用在对象, 方法, 代码块的区别🔝</a></div>
        <p>synchronized关键字的本质是<code>锁对象</code>. 用在对象类型上, 即为锁定目标对象. 用在方法和代码块中, 表示锁定当前对象.对象一旦被锁定,
            所有的synchonized关键字修饰的区域都需要等待锁释放后才能执行.</p>
        <p>前边几个例子都是synchronized锁对象的方式.下面来看看用锁方法和锁代码块.</p>
        <pre class="prettyprint"><code class="java language-java">package com.dashidan.lesson18;

/**
 * 大屎蛋教程网-dashidan.com
 * &lt;p&gt;
 * Java教程基础篇:  18.Java线程
 * synchronized锁方法和区块
 */
public class Demo7 {
    public static void main(String[] args) {
        SyncObject syncObject = new SyncObject();
        Demo7Thread t1 = new Demo7Thread("t1", syncObject);
        t1.start();
        Demo7Thread t2 = new Demo7Thread("t2", syncObject);
        t2.start();
    }
}

class SyncObject {

    /**
     * synchronized 锁方法
     */
    public synchronized void testSyncMethod(String name) {
        try {
            System.out.println(name + "运行testSyncMethod开始.");
            Thread.sleep(300);
            System.out.println(name + "运行testSyncMethod结束.");
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    /**
     * synchronized 锁代码区块
     */
    public void testSyncCode(String name) {
        synchronized (this) {
            try {
                System.out.println(name + "运行testSyncCode开始.");
                Thread.sleep(300);
                System.out.println(name + "运行testSyncCode结束.");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}

class Demo7Thread extends Thread {
    SyncObject syncObject;

    public Demo7Thread(String name, SyncObject syncObject) {
        super(name);
        this.syncObject = syncObject;
    }

    @Override
    public void run() {
        syncObject.testSyncMethod(this.getName());
        syncObject.testSyncCode(this.getName());
    }
}
</code></pre>
        <p>输出:</p>
        <pre><code>t1运行testSyncMethod开始.
t1运行testSyncMethod结束.
t2运行testSyncMethod开始.
t2运行testSyncMethod结束.
t1运行testSyncCode开始.
t1运行testSyncCode结束.
t2运行testSyncCode开始.
t2运行testSyncCode结束.
</code></pre>
        <div class="bs-callout">
            <p>运行结果可能不一样, 但开始和结束总是一一对应.在开始和结束之间没有执行其他方法,
                说明都是锁的同一个对象.可以将任意一个synchronized屏蔽,再跑一下程序,就会发现输出中的开始和结束不再一一对应.</p>
        </div>
        <div class="dsd_title"><a href="#top" id="⑨">⑨ Lock对象🔝</a></div>
        <p>JDK1.5开始提供了一个更加高效的锁的方式.concurrent包中Lock对象.最大的优势是可以读写锁分离, 加入写锁后, 读锁需要等写锁释放后再进行. 加入读锁后, 还是可以获取写锁, 为了保证数据安全,
            使用写锁的时候. 同一个对象可以使用多个Lock对象, 锁定对应的范围, 而不像synchonized锁整个对象.
            官方例子</p>
        <pre class="prettyprint"><code class="java language-java">class CachedData {
    Object data;
    volatile boolean cacheValid;
    final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();

    void processCachedData() {
        rwl.readLock().lock();
        if (!cacheValid) {
            // Must release read lock before acquiring write lock
            rwl.readLock().unlock();
            rwl.writeLock().lock();
            try {
                // Recheck state because another thread might have
                // acquired write lock and changed state before we did.
                if (!cacheValid) {
                    data =...
                    cacheValid = true;
                }
                // Downgrade by acquiring read lock before releasing write lock
                rwl.readLock().lock();
            } finally {
                rwl.writeLock().unlock(); // Unlock write, still hold read
            }
        }
        try {
            use(data);
        } finally {
            rwl.readLock().unlock();
        }
    }
}
</code></pre>
        <p>一个简单的读写锁例子</p>
        <pre class="prettyprint"><code class="java language-java">package com.dashidan.lesson18;

import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantReadWriteLock;

/**
 * 大屎蛋教程网-dashidan.com
 * &lt;p&gt;
 * Java教程基础篇:  18.Java线程
 * Lock对象
 */
public class Demo8 {

    public static void main(String[] args) {
        LockObjectReadAndWrite lockObj = new LockObjectReadAndWrite();
        /** 写线程*/
        WriteThread writeThread = new WriteThread("w1", lockObj);
        writeThread.start();
        /** 读线程*/
        ReadThread readThread = new ReadThread("r1", lockObj);
        readThread.start();
    }
}

class LockObjectReadAndWrite {

    private final Map&lt;String, Integer&gt; m = new HashMap&lt;&gt;();
    private final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();
    private final Lock readLock = rwl.readLock();
    private final Lock writeLock = rwl.writeLock();

    public Integer get(String key, String threadName) {
        System.out.println("加入读锁 " + threadName);
        readLock.lock();
        try {
            System.out.println("读取休息1秒");
            Thread.sleep(1000);
            return m.get(key);
        } catch (InterruptedException e) {
            e.printStackTrace();
            return -1;
        } finally {
            readLock.unlock();
            System.out.println("释放读锁 " + threadName);
        }
    }

    public Integer put(String key, Integer value, String threadName) {
        System.out.println("------WriteThread 加入写锁------ : " + threadName);
        writeLock.lock();
        try {
            System.out.println("写入休息6秒.....");
            Thread.sleep(6000);
            return m.put(key, value);
        } catch (InterruptedException e) {
            e.printStackTrace();
            return -1;
        } finally {
            writeLock.unlock();
            System.out.println("------WriteThread 释放写锁------: " + threadName);
        }
    }
}

class WriteThread extends Thread {

    LockObjectReadAndWrite lockObj;

    public WriteThread(String name, LockObjectReadAndWrite lockObj) {
        super(name);
        this.lockObj = lockObj;
    }

    @Override
    public void run() {
        while (true) {
            /** 持续写入*/
            lockObj.put("a", 1, this.getName());
            /** 写入线程休息3秒*/
            try {
                Thread.sleep(3000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

        }
    }
}

class ReadThread extends Thread {

    LockObjectReadAndWrite lockObj;

    public ReadThread(String name, LockObjectReadAndWrite lockObj) {
        super(name);
        this.lockObj = lockObj;
    }

    @Override
    public void run() {
        while (true) {
            /** 持续读取*/
            lockObj.get("a", this.getName());
        }
    }
}
</code></pre>
        <p>输出:</p>
        <pre><code>加入读锁 r1
读取休息1秒
------WriteThread 加入写锁------ : w1
释放读锁 r1
写入休息6秒.....
加入读锁 r1
------WriteThread 释放写锁------: w1
读取休息1秒
释放读锁 r1
加入读锁 r1
读取休息1秒
释放读锁 r1
加入读锁 r1
读取休息1秒
------WriteThread 加入写锁------ : w1
写入休息6秒.....
释放读锁 r1
加入读锁 r1
</code></pre>
        <div class="bs-callout">
            <p>输出结果可能不一样. 但每次加上写锁之后, 读取的操作便停止. 释放写锁后, 读取继续.</p>
        </div>
        <div class="dsd_title"><a href="#top" id="⑩">⑩ 线程常见问题 🔝</a></div>
        <ul>
            <li>线程的名字</li>
        </ul>
        <p>默认线程名:<code>Thread-</code>加<code>下一线程数</code>:</p>
        <pre class="prettyprint"><code class="java language-java">public Thread() {
    init(null, null, "Thread-" + nextThreadNum(), 0);
}
</code></pre>
        <p>自定义线程名:</p>
        <p>在构造函数中传入线程名.</p>
        <pre class="prettyprint"><code class="java language-java">public Thread(Runnable target, String name) {
    init(null, target, name, 0);
}
</code></pre>
        <ul>
            <li>获取当前线程对象的方法</li>
        </ul>
        <pre class="prettyprint"><code class="java language-java">Thread.currentThread().
</code></pre>
        <ul>
            <li>当线程目标<code>run()</code>方法结束时, 该线程结束.</li>
            <li>一个线程只能启动一次, 一旦线程启动, 不能再重新启动.</li>
            <li>线程的调度由Java虚拟机(JVM)控制.</li>
        </ul>
        <p>
            在单核CPU的电脑上,实际上一次只能运行一个线程,CPU分时处理,看上去向同步运行一样.多核CPU的电脑同时可以运行多个线程.Java虚拟机决定实际运行哪个线程.有多个可运行线程时,其中的某一个会被Java虚拟机选为当前线程.默认情况下不能保证线程运行的先后顺序.量子理论的上帝掷骰子.</p>
        <p><img class="center-block img-responsive" src="http://dashidan.com/img/common/aiyinsitan.jpg" alt="爱因斯坦"/></p>
        <div class="dsd_title"><a href="#top" id="⑪">⑪ 相关文章🔝</a></div>
        <p>📖 <a href="http://dashidan.com/article/java/addenda/Java示例代码使用方法.html">Java示例代码使用方法</a></p>
    </div>
    <hr>
    <!-- 底部面包屑导航-->
    <ol class="breadcrumb">
        <li><a href="http://dashidan.com/index.html"><b>首页</b></a></li>
        <li><a href="http://dashidan.com/article/java/index.html"><b>Java教程</b></a></li>
        <li class="active"><a
            href="http://dashidan.com/article/java/basic/index.html"><b>教程列表</b></a></li>
    </ol>
    <hr>
    <!--<nav>-->
    <div class="text-center">
        <div>
            <a href="http://dashidan.com/article/java/basic/Java转义字符.html">🔺 上一篇: Java转义字符</a>
        </div>
        <div>
            <a href="http://dashidan.com/article/java/basic/Java设计模式.html">🔻 下一篇: Java设计模式</a>
        </div>
    </div>
    <!--</nav>-->
</div>

<div style="display:none;">
    <script src="https://s19.cnzz.com/z_stat.php?id=1264355070&web_id=1264355070" language="JavaScript"></script>
</div>

<script src="http://dashidan.com/js/jquery-3.2.1.min.js"></script>
<script src="http://dashidan.com/js/vendor/modernizr-custom.js"></script>
<script src="http://dashidan.com/js/bootstrap.js"></script>
<script src="http://dashidan.com/js/google-code-prettify/run_prettify.js"></script>
</body>
</html>
