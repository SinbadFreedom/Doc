https://www.w3.org/TR/2017/REC-html52-20171214/introduction.html#a-quick-introduction-to-html

1.9.1。用HTML编写安全的应用程序
本节不具规范性。

当HTML用于创建交互式网站时，需要注意避免引入攻击者可以通过其损害网站本身或网站用户完整性的漏洞。

对此问题的全面研究超出了本文的范围，强烈建议作者更详细地研究此事。但是，本节试图快速介绍HTML应用程序开发中的一些常见缺陷。

Web的安全模型基于“起源”的概念，相应地，Web上的许多潜在攻击都涉及到跨源操作。[起源]

不验证用户输入
跨站点脚本（XSS）

SQL注入
当接受不受信任的输入时，例如用户生成的内容（如文本注释，URL参数中的值，第三方站点的消息等）时，必须在使用前验证数据，并在显示时妥善转义。如果不这样做，可能会导致恶意用户执行各种攻击，从潜在的良性（如提供负面年龄等虚假用户信息）到严重（如每次用户查看页面时运行脚本）包括可能将进程中的攻击传播到灾难性的信息，例如删除服务器中的所有数据。

当编写过滤器来验证用户输入时，过滤器总是基于安全列表，这是必要的，允许已知安全的构造并禁止所有其他输入。基于阻止列表的过滤器不允许已知错误输入并允许其他所有内容都不安全，因为不是所有不好的内容都是已知的（例如，因为它可能在未来发明）。

例如，假设页面查看其URL的查询字符串以确定要显示的内容，然后该站点将用户重定向到该页面以显示消息，如下所示：
< UL > 
  < 李> < 一个 HREF = “message.cgi？发言权=你好” >问好</ 一> 
  < 李> < 一个 HREF = “message.cgi？说=欢迎” >说欢迎</ 一> 
  < 李> < 一个 HREF = “message.cgi？发言权=小猫” >说小猫</ 一> 
</ UL >
如果该消息只是在不逃脱的情况下向用户显示，则敌对攻击者可以制作一个包含脚本元素的URL：

http://example.com/message.cgi?say=%3Cscript%3Ealert%28%27Oh%20no%21%27%29%3C/script%3E
如果攻击者说服受害者用户访问该页面，则攻击者选择的脚本将在页面上运行。这样的脚本可以执行任何数量的敌对行为，仅受网站提供的限制：例如，如果该网站是电子商务商店，则该脚本可能会导致用户在不知情的情况下进行任意多次不必要的购买。

这被称为跨站脚本攻击。

有许多构造可以用来欺骗网站执行代码。以下是一些作者在编写安全列表过滤器时被鼓励考虑的问题：

当允许无害看似的元素时img，重要的是安全地提供任何提供的属性。如果有人允许所有属性，那么攻击者可以使用该onload属性来运行任意脚本。

当允许提供URL（例如链接）时，每个URL的方案也需要明确安全列表，因为有许多方案可能被滥用。最突出的例子是“ javascript:”，但用户代理可以实现（并且确实历史上已经实现）其他。

允许base插入一个元素意味着script页面中任何具有相对链接的元素都可以被劫持，并且类似地，任何表单提交都可以被重定向到一个恶意网站。

跨站请求伪造（CSRF）
如果某个网站允许用户通过用户特定的副作用进行表单提交，例如在用户名下的论坛上发布消息，进行购买或申请护照，请务必确认该请求是由用户故意而不是由另一个网站诱骗用户不知不觉地提出请求。

存在此问题是因为HTML表单可以提交给其他来源。

站点可以通过使用特定于用户的隐藏令牌填充表单或通过检查Origin所有请求的标头来防止此类攻击。

点击劫持
为用户提供接口来执行用户可能不希望执行的操作的页面需要进行设计，以避免用户可能被诱骗进入激活接口的可能性。

用户可能如此被欺骗的一种方式是，如果敌对网站将受害者站点放置得很小iframe，然后说服用户点击，例如通过让用户玩反应游戏。一旦用户玩游戏，恶意网站可以iframe在用户即将点击时快速定位鼠标光标，从而欺骗用户点击受害者站点的界面。

为了避免这种情况，鼓励不希望在框架中使用的网站只在检测到它们不在框架中时才启用它们的接口（例如，通过比较window对象与top属性的值）。

1.9.2。使用脚本API时要避免常见的缺陷
本节不具规范性。

HTML中的脚本具有“run-to-completion”语义，这意味着浏览器通常会在执行其他任何事情之前不间断地运行脚本，例如发起更多事件或继续解析文档。

另一方面，HTML文件的解析会逐渐发生，这意味着解析器可以随时暂停以让脚本运行。这通常是一件好事，但这确实意味着作者需要小心避免事件可能被触发后挂钩事件处理程序。

有两种技术可以可靠地做到这一点：使用事件处理程序内容属性，或创建元素并在同一脚本中添加事件处理程序。后者是安全的，因为如前所述，在进一步的事件发生之前脚本可以完成。

这可以体现出来的一种方式是img元素和load事件。事件可能在元素被解析后立即触发，特别是如果图像已被缓存（这是常见的）。
在这里，作者使用元素onload上的处理程序img来捕捉load事件：

< img  src = “games.png”  alt = “游戏”  onload = “gamesLogoHasLoaded（event）” >
如果元素是通过脚本添加的，那么只要事件处理程序添加到同一个脚本中，事件仍然不会被忽略：

< script > 
var img =  new Image （）; 
img 。src =  'games.png' ; 
img 。alt =  '游戏' ; 
img 。onload = gamesLogoHasLoaded ; 
// img.addEventListener（'load'，gamesLogoHasLoaded，false）; //也可以工作
</ script >
但是，如果作者首先创建了该img元素，然后在单独的脚本中添加了事件侦听器，则有可能会在该load事件之间触发事件，从而导致错过：

<！ - 不要使用这种风格，它有竞争条件！- > 
< img  id = “games”  src = “games.png”  alt = “游戏” > 
<！ - 解析器正在
    休息时，
'load'事件可能会在此处触发，在这种情况下，您将看不到它！- > < script > 
var img =文档。getElementById （'游戏' ）; 
img 。onload = gamesLogoHasLoaded ;  //可能永远不会开火！
</ script >
1.9.3。如何在编写HTML时遇到错误：验证器和一致性检查器
本节不具规范性。

鼓励作者使用一致性检查器（也称为验证器）来捕捉常见错误。W3C提供了许多在线验证服务，包括Nu Markup验证服务。