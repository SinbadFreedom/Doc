3.1.1 整数类型

进制种类	引导符号		描述
十进制		无				0到9组成：1231， 3332
二进制		0b 或 0B		字符0和1组成：0b001001, 0B0010
八进制		0o 或 0O		0到7组成： 0o123766， 0O76222
十六进制	0x 或 0X		0到8，a到f或者A到F组成： 0x11AF， 0x3333

3.1.2 浮点数类型

浮点数表示带有小数的值（必须带有小数，不带小数的为整数， 例如111为整数，111.0为浮点数）。有2种表示方法：十进制形式和科学计数法。

浮点数只有十进制表示形式，除此之外没有其他进制的表示形式。

浮点数举例：

```
111.01
109000.22
1.111e3
2.222E4
```

科学计数法使用字母e或者E作为幂的符号，以10为基数，含义如下：

<a>e<b>表示a乘以(10的b次方)

Python语言的浮点数运算，存在一个"不确定尾数"问题，即两个浮点数运算，有一定概率再运算结果后增加一些"不确定的"尾数。

例如：

```
>>>0.1+0.2
>>>0.30000000000000004
```

去除尾数取整，可以采用round方法，这个方法采用小数部分四舍五入取整。

```
>>>round(0.1+0.2)
>>>0
```

补充：
除此之外，math包中还提供了ceil方法和floor方法，分别为向上取整（大于0进位），和向下取整（舍去小数）。使用这两个方法需要先导入math包。

```
import math
>>>math.ceil(0.1+0.2)
>>>1
>>>math.floor(0.1+0.2)
>>>0
```

3.2 数字型的运算

操作符及运算	描述
x+y				加
x-y				减
x*y				乘
x/y				x除以y，结果为浮点数
x//y			x除以y，结果向下取整
x%y				x除以y的余数，也叫模运算
-x				x的负值
x**y			x的y次幂


运算举例
```
# 12平均律计算2的1/12次幂
>>>2/3
>>>0.6666666666666666
>>>2//3
>>>0
>>>2%3
>>>2
>>>2**(1/12)
>>>1.0594630943592953
```

3.2.2 数值运算函数

函数					描述
abs(x)					x的绝对值
divmod(x,y)				(x//y, x%y),输出为二元组形式（也成为元组类型）
pow(x,y)或pow(x,y,z)	x**y 或者 (x**y)%z 幂运算
round(x)或round(x,d)	x四舍五入，保留d位小数，无参数d，保留整数
max(x,y,z...)			取x,y,z...中的最大值，参数数量无限制
min(x,y,z...)			取x,y,z...中的最小值，参数数量无限制

运算举例
```
>>>abs(-222)
>>>222
>>>pow(2,8)
>>>256
>>>round(3.14159, 2)
>>>3.14
>>>min(1,2,3)
>>>1
>>>divmod(5,3)
>>>(1, 2)
```

3.3 字符串类型及格式化

单行字符串以一对单引号(')或者双引号(")作为边界表示。两者作用相同，使用单引号是双引号做为字符串的一部分，反之亦然。

多行字符串以一对三引号(''')或者三双引号(""")作为边界表示。两者作用相同

```
>>> print("""多行测试
第二行
第三行
""")
	  
多行测试
第二行
第三行
```

注意:
输入多行字符串的时候，不能提前把print的右半个括号和三引号加上，如果提前加，输入回车换号的时候就直接输出了。

转义字符\

\n 		换行
\\ 		反斜杠\
\' 		单引号'
\"		双引号"
\t		制表符，相当于按下tab键

反斜杠\还有一个作用是续行。一行代码太长的时候，可以采用\来续一行接着写

3.3.1 字符串的索引

从左向右 从0开始到长度减一
从右到左 从-1开始到长度的负值

```
>>> "唐伯虎点秋香"[-4]
	  
'虎'
>>> 
```

3.3.2 字符串的切片

<字符串变量>[N:M] 切片获取字符串N到M（不含）的子字符串。

如果N缺失，表示从起始开始，如果M缺失表示到结尾。
N,M都需要在字符串的索引区间，如果N大于M返回空字符串

代码示例：
```
>>> "唐伯虎点秋香"[2:4]
	  
'虎点'
>>> 
>>> "唐伯虎点秋香"[5:4]
	  
''
>>> 
>>> "唐伯虎点秋香"[-1:]
	  
'香'
>>> "唐伯虎点秋香"[-1:-2]
	  
''
>>> "唐伯虎点秋香"[-2:-1]
	  
'秋'
>>> 
```

注意：
这个字符串切提供的是从左到右切的功能。反向切(即N大于M)的时候返回空字符串。

3.3.3 format方法的基本使用


{}默认与format中的参数一一对应，也可以在{}中设置索引编号对应format中的参数。

```
>>> "唐伯虎点{}香".format("秋","蚊")
	  
'唐伯虎点秋香'
>>> 
>>> "唐伯虎点{1}香".format("秋","蚊")
	  
'唐伯虎点蚊香'
>>> 
```

3.3.4 format()方法中的格式控制


格式控制标记包括：<填充><对齐><宽度><,><.精度><类型> 字段可选，可以组合使用。控制字段分为2组。

格式控制语法：{<参数序号>:<格式控制标记>} 。 其中参数序号是指formmat方法中的参数序号。不填时默认为0.

第一组是<填充><对齐><宽度>

<填充> 用于填充的单个字符，字符长度超过1会报编译错误"ValueError: Invalid format specifier"。

对齐使用< > ^这三个符号表示左对齐，右对齐，居中对齐。

```
>>> s = "唐伯虎点秋香"
	  
>>> "{:25}".format(s)
	  
'唐伯虎点秋香                   '
>>> "{:^25}".format(s)
	  
'         唐伯虎点秋香          '
>>> "{:<25}".format(s)
	  
'唐伯虎点秋香                   '
>>> "{:>25}".format(s)
	  
'                   唐伯虎点秋香'
>>> "{:*^25}".format(s)
	  
'*********唐伯虎点秋香**********'
>>> "{:-^25}".format(s)
	  
'---------唐伯虎点秋香----------'
>>> 

>>> s = "唐伯虎点秋香"
	  
>>> x = "唐伯虎点秋香"
	  
>>> y = "-"
	  
>>> "{0:{1}^{2}}".format(x, y, 30)
	  
'------------唐伯虎点秋香------------'
>>> 
```

3.4 字符串类型的操作

3.4.1 字符串操作符

操作符			描述
x + y 			连接两个字符串
x*n 或 n*x		复制n次字符串x
x in s			如果x是s的子字符串，返回True，否则返回False


```
>>> "唐伯虎"*3
	  
'唐伯虎唐伯虎唐伯虎'
>>> 
>>> "唐" in "唐伯虎"
	  
True
>>> 
```

3.4.2 字符串处理函数

函数			描述
len(s)			字符串s的长度，也可返回其他组合数据类型的元素个数
str(s)			返回任意类型s对应的字符串形式
chr(s)			返回Unicode编码s对应的单字符
ord(s)			返回单字符s表示的Unicode编码
hex(s)			返回整数s对应的十六进制字符串
oct(s)			返回整数s对应的八进制字符串


```
>>> chr(9734)
	  
'☆'
>>> chr(0x025b)
	  
'ɛ'
>>> chr(0x2708)
	  
'✈'
>>> chr(0x00A5)
	  
'¥'
>>> chr(0x266b)
	  
'♫'
>>> ord("♫")
	  
9835
>>> ord("☆")
	  
9734
>>> ord("✈")
	  
9992
```

3.4.5 字符串处理方法

方法						描述
str.lower()					返回str的小写副本
str.uper()					返回str的大写副本
str.split(sep=None)			返回一个列表由str根据sep分割构成，省略sep默认以空格分割
str.count(sub)				返回sub子字符串出现的次数
str.replace(old, new)		返回str的副本，所有old子串替换成new
str.center(width, fillchar)	字符串居中，fillchar可选
str.strip(chars)			从字符串左侧和右侧去掉chars中列出的字符， chars是一个字符串，其中出现的每个字符都会被去掉
str.join(iter)				将iter变量的每一个元素后边加一个str字符串

```
>>> "Sos".lower()
	  
'sos'
>>> "Sos".upper()
	  
'SOS'
>>> "sos".center(100, "*")
	  
'************************************************sos*************************************************'
>>>

>>> "Sos".replace("o", "x")
	  
'Sxs'
```

提示：
在IDLE编辑器中输入 '"Sos".'以后稍微等一下，会出现自动提示支持的方法列表，输入对应的方法名和左边的半个括号"("，等一会会自动提示方法的参数类型。


注意：
strip方法中注意包含和不包含最外层的字符是有区别的。以下示例中第二个strip方法中比第一个方法参数中多了一个空格，产生了完全不同的效果。

```
>>> "  ==SoS==  ".strip("=S")
	  
'  ==SoS==  '
>>> "  ==SoS==  ".strip(" =S")
	  
'o'
```

join方法 
split方法
count方法

这三个方法比较简单。不再重复。

3.5 类型判断和类型间转换

Phthon提供type(x)函数对变量x进行类型判断。适用于任何数据类型。

示例代码：

```
n = eval(input("请输入一个数字："))
if type(n) == type(1111):
    print("输入的数字是整数")
elif type(n) == type(1.1):
    print("输入的数字是浮点数")
else:
    print("无法判断输入类型")

```

这个示例代码中的else语句是无法执行到的。比如输入一个字符串"abc"，会在第一行eval方法转化为数字的时候就报错。

```
Traceback (most recent call last):
  File "D:/workplace/git/Doc/educate/python/second_degree/3.5.py", line 1, in <module>
    n = eval(input("请输入一个数字："))
  File "<string>", line 1, in <module>
NameError: name 'a' is not defined
```

这个示例代码不严谨，但用来表示判断是整数类型和浮点数类型够用了。

3.6 实例解析----凯撒密码

```
# CasearEncode.py
ptxt = input("请输入明文文本：")
for p in ptxt:
    if "a" <= p <= "z":
        print(chr(ord("a") + (ord(p)-ord("a") + 3)%26), end="")
    elif "A" <= p <= "Z":
        print(chr(ord("A") + (ord(p)-ord("A") + 3)%26), end="")
    else:
        print(p, end="")
```


运行结果：
```
请输入明文文本：asfasfAASDSDasdasdasd阿斯蒂芬
dvidviDDVGVGdvgdvgdvg阿斯蒂芬
>>> 
```


凯撒密码解密：

```
# CaesarDecode.py
etxt = input("请输入加密后的文本：")
for p in etxt:
    if "a" <= p <= "z":
        print(chr(ord("a") + (ord(p)-ord("a") - 3)%26), end="")
    elif "A" <=p <= "Z":
        print(chr(ord("A") + (ord(p)-ord("A") - 3)%26), end="")
    else:
        print(p, end="")
```

运行结果:

```
请输入加密后的文本：dvidviDDVGVGdvgdvgdvg阿斯蒂芬
asfasfAASDSDasdasdasd阿斯蒂芬
>>> 
```

3.4 凯撒密码中文加密

```
# CasearChineseEncode.py
ptxt = input("请输入明文文本：")
for p in ptxt:
    if "a" <= p <= "z":
        print(chr(ord("a") + (ord(p)-ord("a") + 3)%26), end="")
    elif "A" <= p <= "Z":
        print(chr(ord("A") + (ord(p)-ord("A") + 3)%26), end="")
    elif 0x4E00 <= ord(p) <= 0x9FA5:
        print(chr(ord(p)+3), end= "")
    else:
        print(p, end="")
        
```

运行结果：

```
请输入明文文本：中华人民共和国
丰卑亽气兴咏圀
```

3.5 凯撒密码中文解密

勘误：
书中第三行代码书写错误,in后边少了一个空格,导致程序编译错误。

```
for p inetxt:
```
应改为:
```
for p in etxt:
```

改后的代码:
```
# CaesarChineseDecode.py
etxt = input("请输入加密后的文本：")
for p in etxt:
    if "a" <= p <= "z":
        print(chr(ord("a") + (ord(p)-ord("a") - 3)%26), end="")
    elif "A" <=p <= "Z":
        print(chr(ord("A") + (ord(p)-ord("A") - 3)%26), end="")
    elif 0x4E00 <= ord(p) <= 0x9FA5:
        print(chr(ord(p) - 3), end="")
    else:
        print(p, end="")
```

运行结果：
```
请输入加密后的文本：丰卑亽气兴咏圀
中华人民共和国
```

