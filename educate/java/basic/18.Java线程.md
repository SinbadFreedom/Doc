18. Java线程
===

部分内容源自:《深入理解JVM虚拟机》


1. 线程和进程的概念
---

进程是指一个内存中运行有自己独立的一块内存空间的应用程序.一个进程中至少一个线程.

线程是指进程中的一个执行流程.每个线程有独立的运行栈. 线程从属于进程. 一个进程中可以运行多个线程.进程中的多个线程共享进程的内存.

线程和进程一样分为五个阶段:创建、就绪、运行、阻塞、终止.

多进程是指操作系统能同时运行多个任务(程序).

多线程是指在同一程序中,有多个顺序流在执行.


2. 线程的实现
---
线程是比进程更轻量级的调度执行单位,线程的引入,可以把一个进程的资源分配和执行调度分开,各个线程既可以共享进程资源(内存地址、文件I/O等),又可以独立调度(线程是CPU调度的基本单位).

主流的操作系统都提供了线程实现,Java语言则提供了在不同硬件和操作系统平台下对线程操作的统一处理.

Thread类中所有关键方法都是声明为Native的,在Java API中,本地方法往往意味着这个方法没有使用或无法使用平台无关的手段来实现(当然也有可能是为了执行效率而使用Native方法)

3. Java线程调度
---

Java的线程调度方式是抢占式调度,虽然Java线程的调度是系统自动完成的,但是我们还是可以“建议”系统给某些线程多分配一点执行时间,另外的一些线程则可以少分配一点——这项操作可以通过设置优先级来完成.

不过,线程的优先级并不是太靠谱,因为Java线程是通过映射到原生线程上来实现的,所以线程调度最终还是取决于操作系统,虽然现在很多操作系统都提供了优先级的概念,但是并不见得与Java线程的优先级一一对应.比如:Windows中就只有7种线程优先级,而Java语言一共设置了10个级别的线程优先级.

4. Java线程的状态转化
---
Java线程具有五中基本状态

1. 新建状态(New)

在生成线程对象,并没有调用该对象的start方法.如:

```java
Thread t = new MyThread1();
```

2. 就绪状态(Runnable)

当调用了线程对象的start方法之后,该线程就进入了就绪状态,但是此时线程调度程序还没有把该线程设置为当前线程,此时处于就绪状态.随时等待CPU调度执行,并不是说执行了t.start()此线程立即就会执行. 在线程运行之后,从等待或者睡眠中回来之后,也会处于就绪状态.

3. 运行状态(Running)

线程调度程序将处于就绪状态的线程设置为当前线程,此时线程就进入了运行状态,开始运行run函数当中的代码.

注:
就绪状态是进入到运行状态的唯一入口,也就是说,线程要想进入运行状态执行,首先必须处于就绪状态中.

4. 阻塞状态(Blocked)

线程正在运行的时候,暂时放弃对CPU的使用权,停止执行,此时进入阻塞状态.通常是为了等待某个时间的发生(比如说某项资源就绪)之后再继续运行.sleep,suspend,wait等方法都可以导致线程阻塞.

处于运行状态中的线程直到其进入到就绪状态,才有机会再次被CPU调用以进入到运行状态.根据阻塞产生的原因不同,阻塞状态又可以分为三种:

* 等待阻塞:运行状态中的线程执行wait()方法,使本线程进入到等待阻塞状态.
* 同步阻塞:线程在获取synchronized同步锁失败(因为锁被其它线程所占用),它会进入同步阻塞状态.
* 其他阻塞:通过调用线程的sleep()或join()或发出了I/O请求时,线程会进入到阻塞状态. 当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时,线程重新转入就绪状态.

5. 死亡状态(Dead)

如果一个线程的run方法执行结束或者调用stop方法后,该线程就会死亡结束生命周期.对于已经死亡的线程,无法再使用start方法令其进入就绪.

5. Java中线程的实现
---

在Java中想实现多线程有两种手段,一种是集成Thread类,另一种就是实现Runnable接口.

###1.继承自Thread类

```java
package com.dashidan.lesson18;

/**
 * 大屎蛋教程网-dashidan.com
 * <p>
 * Java教程基础篇:  18.Java线程
 * 继承自Thread类
 */
public class MyThread1 extends Thread {

    @Override
    public void run() {
        System.out.println("MyThread1 run.");
    }
}

```

###2.实现Runnable接口
首先定义一个线程类继承自Runnable接口,如: 
```java
package com.dashidan.lesson18;

/**
 * 大屎蛋教程网-dashidan.com
 * <p>
 * Java教程基础篇:  18.Java线程
 * 实现Runnable接口
 */
public class MyThread2 implements Runnable {
    @Override
    public void run() {
        System.out.println("MyThread2 run.");
    }
}
```

入口类,实例化线程类的对象,发动启动线程的命令
```java
package com.dashidan.lesson18;

/**
 * 大屎蛋教程网-dashidan.com
 * <p>
 * Java教程基础篇:  18.Java线程
 */
public class Demo1 {
    public static void main(String[] args) {
        MyThread1 myThread1 = new MyThread1();
        Thread t1 = new Thread(myThread1);
        t1.start();
    }
}
```

输出:

	MyThread2 run.
	MyThread1 run.
	
<div class="bs-callout bs-callout-warning">
    <h4>输出的顺序可能不一致</h4>
	<p>多运行几次, 输出的顺序可能不一致, 这个是由于线程的执行顺序无法保证导致.</p>
</div>

6. 启动线程
---

在线程的Thread对象上调用start()方法,而不是run()或者别的方法.在调用start()方法之前,线程处于新状态中, 新状态指有一个Thread对象, 但还没有一个真正的线程. 在调用start()方法之后,发生了一系列复杂的事情

1. 启动新的执行线程(具有新的调用栈).
2. 该线程从新状态转移到可运行状态.
3. 当该线程获得机会执行时,其目标run()方法将运行.

注:


<div class="bs-callout bs-callout-danger">
    <h4>run()方法</h4>	
	<p>对Java来说,run()方法是线程启动的入口方法, 同时也是一个普通的方法. 因此,在Runnable上或者Thread上调用run方法是合法的.但并不启动新的线程.所以不建议直接调用run()方法.</p>
</div>

7. 线程常见问题 
---

* 线程的名字

一个运行中的线程总是有名字的,名字有两个来源,一个是虚拟机自己给的名字,一个是你自己的定的名字.在没有指定线程名字的情况下,虚拟机总会为线程指定名字,并且主线程的名字总是mian,非主线程的名字不确定.

线程都可以设置名字,也可以获取线程的名字,连主线程也不例外.

* 获取当前线程对象的方法

Thread.currentThread().

* 一系列线程以某种顺序启动并不意味着将按该顺序执行. 对于任何一组启动的线程来说,调度程序不能保证其执行次序,持续时间也无法保证.

* 当线程目标run()方法结束时,该线程结束.

* 一个线程只能启动一次,一旦线程启动,就不能再重新启动.

* 线程的调度是JVM的一部分. 

在单核CPU的电脑上,实际上一次只能运行一个线程.多核CPU的电脑同时可以运行多个线程.JVM线程调度程序决定实际运行哪个处于可运行状态的线程.

* 众多可运行线程中的某一个会被选中做为当前线程.可运行线程被选择运行的顺序是没有保障的.

8. 相关文章
---

* [Java示例代码使用方法](http://localhost/article/java/addenda/Java示例代码使用方法.html)   